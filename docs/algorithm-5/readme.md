<!-- Date: 2017-06-06 21:27 -->

# algorithm 基础算法之希尔排序

今天记录一下插入排序中的另一个升级版：希尔排序

## 算法思路

设定一个初始增量值，把数组分为若干个子数组，再对每一个子数组执行插入排序，逐步将增量之减少为上一个增量之的二分之一，直到增量值到 1 未知

## 代码实现

```js
//形参增加步数gap(实际上就相当于gap替换了原来的数字1)
function directInsertionSort(array, gap) {
    gap = gap == undefined ? 1 : gap; //默认从下标为1的元素开始遍历
    var length = array.length,
        index,
        current;
    for (var i = gap; i < length; i++) {
        index = i - gap; //待比较元素的下标
        current = array[i]; //当前元素
        while (index >= 0 && array[index] > current) {
            //前置条件之一:待比较元素比当前元素大
            array[index + gap] = array[index]; //将待比较元素后移gap位
            index -= gap; //游标前移gap位
        }
        if (index + gap != i) {
            //避免同一个元素赋值给自身
            array[index + gap] = current; //将当前元素插入预留空位
        }
    }
    return array;
}
// 那么希尔排序的算法实现如下:
function shellSort(array) {
    var length = array.length,
        gap = length >> 1,
        current,
        i,
        j;
    while (gap > 0) {
        directInsertionSort(array, gap); //按指定步长进行直接插入排序
        gap = gap >> 1;
    }
    return array;
}
```

## 模拟案例

比如我们要对数组[7,4,8,2,9,3,4,0,1,6]进行希尔排序，数组的长度为 10， 所以我们的初始增量值为 5

那么我们的子数组就是[7,3][4,4] [8,0][2,1] [9,6]分别进行直接插入排序后的结果为:

```
[3,4,0,1,6,7,4,8,2,9]
```

增量值减一后的结果为 2，子数组分别是[3,0,6,4,2][4,1,7,8,9] ,分别进行插入排序后的结果为

```
[0,1,2,4,3,7,4,8,6,9]
```

增量值减一后的结果为 1，子数组是[0,1,2,4,3,7,4,8,6,9] ,分别进行插入排序后的结果为

```
[0,1,2,3,4,4,6,7,8,9]
```

## 分析

上面是一个普通的案例，在某些特殊情况下，第一次排序的结果可能就是我们希望看到的排序结果，就会导致后续的遍历成为多余、无效的遍历，因此希尔排序可能会造成时间的浪费。

而且由于希尔排序是由直接插入排序升级而成，也会导致相同元素排序后的相对顺序发生变化，因此希尔排序也是一个不稳定排序

另外如果注意看的话，就会发现在希尔排序的代码实现中，我们不管是交换元素位置，还是最后的把参照元素插入预留空位，都是以增量值为基础的。这个是与我们前面直接插入排序的最大区别。
