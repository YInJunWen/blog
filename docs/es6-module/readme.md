## module 的使用条件

> ES6 中的 module 如果用在浏览器中，需要先使用 babel 编译，因为浏览器环境可能没有部署对于 module 相关的语句和方法

## 安装以及使用 babel

```
npm i babel-cli babel-preset-env -D
```

并在 package.json 做如下配置

```js
{
    "script":{
        "build" :"npx babel src -d dist"
    }
}
```

> 注意配置文件中使用的 npx 命令，他会按照以下方式查找项目内的 npm 包，

- 在项目内查找是否安装对应的 npm 包
- 在全局的 node_modules 中查找是否安装对应的 npm 包
- 如果都找不到，则会临时在项目中安装 npm 包，自动执行后，删除安装包

上面的步骤完成后，可以使用`npm run build`执行编译命令

## 为什么要有 module

最初的 JS 只是作为运行在浏览器中的脚本存在，所有的代码都在一个文件中，也没有模块的概念。在 NodeJS 出现之后，出现了 CommonJS 规范，用来补充没有模块化开发这一部分的缺陷。在 NodeJS 中可以把代码写在多个文件中，在需要用的时候，通过引入模块来使用模块内部的方法或属性。

CommonJs 设计之初是为了在 Server 端运行的，因为 Server 端只需要在本地内存上读取文件就可以，速度很快，不会影响后续代码的执行。

但在浏览器上不能这么执行，因为浏览器加载文件的速度取决于很多因素，比如网速等。因此，又出现了 AMD 规范，主要用于客户端的运行。

ES6 的 module 在 CommonJS 规范的基础上，又做了优化.

不管是 CommonJS 还是 AMD 规范实现的模块，都是在运行的时候，才能确定模块之间的依赖关系，

而 ES6 中的 module 则在编译的过程中，就可以确定需要引入哪些模块。

假设有三个模块`a.js, b.js, c.js`， a 模块中只引入了 b 模块， 在编译的时候，只会把 a 模块和 b 模块的内容引入
