# Linux 基础

#### 命令格式

* 个别命令使用不遵循这个格式
* 命令 [选项][参数]
* 当有多个选项的时候可以写在一起
* 简化选项与完整选项： -a 等于 --all
* 查询目录中内内容 LSls [选项][参数]

#### ls -a

#### Linux 的文件类型

例子： -rw-r--r--
linux 是没有扩展文件类型后缀的
linux 文件类型只有 7 种

* 如果第一位是 & - & ： 代表是一个普通文件
* 如果第一位是 & d & : 代表是一个目录
* 如果第一位是 & | & ： 代表是一个软连接文件（快捷方式）
* 第一位如果是 其他字符 是 linux 特殊文件，不常用
  2-10 位字符每 3 个分为一组，主要功能是分配权限，包含了对（所有者，所属组，其他人）的权限分配
  r 读，w 写，x 执行最后一个 . 暂且先不管
  1 代表文件的 引用计数第一个 root 标示文件的所属人（文件的主人）第二个 root 标示文件的所属组 （文件主人在的用户组）
  ls -h 标示用人类可以理解的方式显示文件的大小文件的最后修改时间文件名

#### 以 . 开头的文件是什么

* 这些文件都是 Linux 的隐藏文件，防止用户误操作
  Linux 常用目录

* **根目录下** 的 bin 和 sbin ；**/usr/** 目录下的 bin 和 sbin 保存的都是执行命令，不同的是根目录下的是只要 root 用户才能使用的命令，user 下的只有一般用户才能使用的命令

```
/boot/    保存的是系统启动文件 ，这个是被单独分区的文件
/dev/     保存的都是硬件的文件，不能动
/etc/     保存的是系统默认的配置文件，配置服务的时候，会用到这个目录
/home/    普通用户的家目录
/root/    超级用户的家目录
/lib/     Linux系统的函数库
/misc/    外接磁带机的挂载点，老式的linux中是没有这个的，不推荐使用
/media/   光盘的挂载点，老式的linux中是没有这个的，不推荐使用
/mnt/     移动U盘之类的挂载点
/proc/    系统内存的挂载点，不能直接操作
/sys/     系统内存的挂载点，不能直接操作
/tmp/     临时文件目录
/usr/     系统资源保存目录
/var/     保存系统的可变文档目录
```

#### 软连接和硬链接的区别是什么？

```
硬链接的特点：
- 拥有相同的 I 节点和存储 block 块，可以看做是同一个文件
- 可以通过 i 节点识别
- 不能跨分区
- 不能针对目录使用

软连接的特点：
- 拥有自己的 i 节点和存储 block 块，但是数据块中只保存源文件的文件名和 i  节点号，并没有实际的文件数据
- lrwxrwxrex 软连接的标示符为 l
- 修改任意文件另一个都会改变
- 删除源文件，软连接不能使用
- 如果源文件被删除，软连接文件后面的源文件位置提示会报错
- 创建软连接的时候，源文件一定要写 绝对路径
```

---------------------------------------------------------搜索命令-------------------------------------------------

#### locate 命令中的搜索规则是什么意思？ 搜索规则在 /ect/updatedb.config 中

* 第一行代表 是否按照以下规则执行
* 第二行代表 不搜索属于后面文件系统里面的文件
* 第三行代表 不搜索文件名包含后面字符的文件
* 第四行代表 不搜索在后面列表中文件夹中的文件

#### whereis which 命令有什么区别

* whereis 命令会输出命令所在的位置 以及命令的帮助文件所在位置
* which 命令会输出命令的别名 以及命令的位置，如果命令是一个简写命令 ，他还会输出完整的命令内容比如：

```
[root@localhost ~]# which lsaliasls='ls --color=auto'
 /bin/ls
```

#### Linux 中的通配符

```
*       匹配任意内容
？      匹配任意一个字符
[]      匹配任意一个中括号内的字符
注意： 如果要使用 find 命令进行模糊查询 必须要加引号并且使用通配符
```

#### 一些没有所有者的文件是什么意思？

正常来说 没有所有者的文件是 垃圾文件

* 第一种特殊情况： Linux 内核产生的文件 是没有所有者的
* 第二种特殊情况： 外来的文件（比如 windows 系统生成的文件是没有所有者这个定义的）

#### 扇区的定义

* 系统中默认一个扇区的大小是 512 个字节，因此在使用命令
  find -size25
* 如果是没有加单位，这里的 25 值得是 25 个扇区的大小 ，也就是 25\*512 个字节的文件大小

#### find 和 grep 的区别

* find 在目录中查找文件，如果需要模糊查询，使用的是通配符
* grep 在文件中查找字符串，如果需要模糊查询，使用的是正则表达式

#### Linux 里面的帮助命令的区别

```
whereis
whatis
--help    查看命令 的帮助信息
man       查看命令的帮助信息(这个在CentOS6.5之后要自行安装包)
```

#### Linux 中的 常见 压缩格式都有那些？

* .zip
* .gz
* .bz2
* .tar.gz
* .tar.bz2

#### shutdown 命令后 终端被锁定，不能输入

* 可以在关机命令后 语句后面添加 & 把命令放到后台执行
  shutdown -h 24:00 &
* 要注意的事项：

* 但是在实际使用中，尽可能不要使用 关机 命令 ，要用远程 重启 命令有的服务器提供商提供了远程关机或者重启的功能，但是他们不会保存当前未保存的数据，只有 shutdown 命令可以 - 先保存数据，再进行关机或者重启要慎重的使用关机或者重启命令，如果有大量的访问量，强行重启或者关机命令有很大可能导致计算机系统损毁啊，甚至硬件损毁

#### 系统运行级别

* 0 关机
* 1 单用户
* 2 不完全多用户，不含 NFS 服务
* 3 完全多用户
* 4 未分配
* 5 图形界面
* 6 重启

#### 如何修改开机启动运行级别

cat /etc/inittab

* 里面有一个 ID：3 initdefault 选项

### ---------------------------------------------------- VIM 基础 ----------------------------------------

#### echo 输出命令

```
echo [选项] [输出内容]
选项：
-e ： 支付反斜线控制的字符转换
```

注意事项：

* 1.如果输出内容有空格存在，内容两边必须添加双引号 `echo&hello world&`
* 2.如果添加了选项 -e ，双引号里面支持使用反斜线控制的字符转换`echo -e &h\te\tl\nl\to&`,输出：`hell o`
* 3.十六进制字符(根据 ASCII 码)`echo -e &\x68\t\x65\t\x6c\n\x6c\t\x6f\t&`, 输出：`hell o`
* 4.使用颜色字符;以 \e1 开头， ; 后面是颜色字符，结尾以 \e[0m 结束`echo -e &\e[1;31mhello world\e[0m&`输出：`hello world (这里应该是有颜色的文字)`

#### alias 查看/修改命令的默认选项

```
alias vi='vim'
```

注意： 这里的修改只是临时有效的，服务器重启之后，就恢复原状了，如果想要永久生效，需要在/root/.bashrc 文件中添加这个别名命令

#### 命令生效顺序

* 第一顺位执行用绝对路径或相对路径执行的命令
* 第二顺位执行别名
* 第三顺位执行 bash 的内部命令
* 第四顺位执行按照$PATH 环境变量定义的目录查找顺序找到的第一个命令

#### 常用命令快捷键

```
ctrl+c  强行终止命令
ctrl+l  清屏
ctrl+a  光标移动到命令行首
ctrl+e  光标移动到命令行尾
ctrl+u  从光标所在的位置删除到行尾
ctrl+z  吧命令放入后台
ctrl+r  在历史命令中搜索
```

#### 家目录中的 .bash_history 文件内容与 history 命令 输出的内容不一致：

.bash_history 文件中保存的是上次关机之前保存的命令，而 history 中保存的包括当前开机之后的所有命令记录正常情况下，系统关机的时候，会自动执行 history -w 命令，即把缓存中的历史命令写入.,bash_history 文件注意：历史记录默认只能记录 1000 条记录，如果需要修改要找到/etc/profile 文件，修改 HISTSIZE 值重复执行历史命令

使用上下箭头调用之前的历史命令使用 !n 重复执行第 n 条历史命令使用 !! 重复执行上一条命令使用 !字符串 重复执行最后一条以该字符串开头的命令输出重定向要注意的事项：

| 命令                   | 作用                                              |
| ---------------------- | ------------------------------------------------- |
| 命令 > 文件            | 正确覆盖输出： (符号两边有空格)                   |
| 命令 >> 文件           | 正确追加输出： (符号两边有空格)                   |
| 命令 2>文件            | 错误覆盖输出： (符号右边没有空格)                 |
| 命令 2>>文件           | 错误追加输出： (符号右边没有空格)                 |
| 命令 > 文件 2>&1       | 把正确输出和错误输出都覆盖保存 (符号两边有空格)   |
| 命令 >> 文件 2>&1      | 把正确输出和错误输出都追加保存 (符号两边有空格)   |
| 命令 &>文件            | 把正确输出和错误输出都覆盖保存 (符号右边没有空格) |
| 命令 &>>文件           | 把正确输出和错误输出都追加保存 (符号右边没有空格) |
| 命令 >>文件 12>>文件 2 | 把正确输出追加到文件 1,错误输出追加到文件 2       |

#### Linux 中的特殊符号

| 符号                                                             | 作用                                                                                                                        |
| ---------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| '                                                                | 单引号，单引号中的所有特殊符号，都没有特殊含义                                                                              |
| &&                                                               | 双引号，双引号中的特殊符号，都没有特殊含义，但是 “ $ ”,“ ` ”,“ / ” 是例外,拥有： 调用变量的值、引用命令和转转移符的特殊含义 |
| `` |反引号，引用系统命令，在 Bash 中会先执行它 ，与 $() 作用一样 |
| $()                                                              | 和反引号作用一样，引用系统变量                                                                                              |
| #                                                                | 在 SHELL 的脚本中，开头的行表示注释                                                                                         |
| $                                                                | 用于调用变量的值，需要以 $name 的方式                                                                                       |
| \                                                                | 转移符，所有跟在这个符号后面的特殊符号，都会失去特殊含义，变成普通字符                                                      |

#### 管道符

分号: 连续执行多个命令

```
[root@liyun ~] # ls; cd /etc/; ls; cd /mnt; ls
分号: 连续执行多个命令
```

双 && 符号： 前面的正确执行，才能执行后面的命令分号: 连续执行多个命令

```
[root@liyun ~] # ls && echo yes
分号: 连续执行多个命令
```

双 || 符号: 前面的没有正确执行，才能执行后面的命令

```
[root@liyun ~] # lsddd || echo no
```

用 && 和 || 判断前面的命令执行结果

```
[root@liyun ~] # ls && echo yes || echono
```

单 | 符号：第二个命令去执行第一个命令的输出结果

```
[root@liyun ~] # ls -alh | more
[root@liyun ~] # netstat | grep
```

#### VIM 底行模式常用指令

```
:w      写入文件
:q      退出编辑
:!      强制退出
:ls     查看所有正在编辑的文件
:n      查看下一个搜索的字符位置(也是重新定位光标所在位置)
:15     移动光标到指定行位置
:/xxx   向后搜索，移动光标到找到的第一个指定字符串的位置
:?xxx   向前搜索，移动光标到找到的第一个指定字符串的位置
h       光标左移
j       光标下移
k       光标上移
l       光标右移
ctrl+f  向下翻页
ctrl+b  向上翻页
ctrl+d  向上翻半页
ctrl+u  向下翻半页
dd      删除光标所在的行
o       在光标所在行的下方插入一行，并切换到插入模式
yy      复制光标所在行
p       在光标所在行下方粘贴
P       在光标所在行上方粘贴
```

### ---------------------------------------------------RPM 包安装基础----------------------------------------

#### RPM 包命名规则

* 软件包名
* 软件版本
* 软件发布次数
* 适合的 Linux 平台
* 适合的硬件平台
* 包扩展名

#### RPM 包安装

```
rpm -ivh 包全名
-i: install
-v: verbose 显示安装详情
--nodeps 不检查依赖（安装的时候强烈建议不要使用）
RPM包的升级和卸载
```

#### 升级：

```
rpm -Uvh 包全名
-u: update 升级
```

#### 卸载：

```
rpm -e 包名
-e: erase 卸载
```

#### RPM 包查询

```
rpm -q 包名
-q: query 查询
-a: all 查询所有安装的包
```

#### RPM 包详情查询

```
rpm -qi 包名
-q: query
-i: information
-p: package 查询未安装包的信息 这里要用包全名
```

#### RPM 包安装位置

```
rpm -ql 包名(包全名)
-l: list   查询软件包的安装位置或者要安装的位置
```

#### 查询系统文件属于哪个软件包

```
rpm -qf 文件名
-f: file  文件名
```

#### RPM 包默认安装位置

```
/etc/           配置文件安装目录
/usr/bin/       可执行的命令安装目录
/usr/lib/       程序所使用的函数库保存位置
/usr/share/doc/ 基本的软件使用手册保存位置
/usr/share/man/ 帮助文件保存位置
```

#### 校验 RPM 安装包

```
rpm -V 包名
-V： verify 校验
```

#### 校验信息：

```
S   文件打下欧是否被改变
M   文件累心过着文件的权限是否被改变
5   MD5是否改变
D   设备的主从代码是否改变
L   文件的路径是否改变
U   文件的属主（所有者）是否改变
G   文件的属组是否改变
T   文件的修改时间是否被改变
```

#### 文件类型：

```
c   配置文件
d   普通文档
g   鬼（ghost file）文件，很少见，就是该文件不应该被这个RPM包含
L   授权文件
r   描述文件
```

#### RPM 包中文件提取

```
rpm2cpio 包全名 | cpio -idv 文件绝对路径
- rpm2cpio 将RPM包转换为cpio格式的命令
- cpio      是一个标准工具，用于创建软件档案文件，和从档案文件中提取文件
    -i: copy-in模式，还原
    -d: 还原时自动新建目录
    -v：显示还原过程
```

### ----------------------------------------------------YUM 安装基础---------------------------------------------

#### 常用 yum 命令

```
通用选项： -y        自动回答 yes
yum list            查看所有的yum源代码包
yum search 关键字    搜搜服务器上源代码包
yum install 包名        安装包  
yum update              升级包
yum remove              卸载包(慎用)
要注意：
服务器使用最小化安装，用设么软件安装设么，尽量不卸载
```

### ----------------------------------------------------脚本安装包---------------------------------------------

实际上 Linux 是没有脚本安装包的，实际上是用脚本的方式，安装 RPM 包或者源码包

### ----------------------------------------------------NGINX 服务器---------------------------------------------

nginx 在反向代理、Rewrite 规则、稳定性、静态文件处理、内存消耗等方面，表现出了很强的优势，一台 nginx 服务器相当于三台左右 apache 服务器

### ----------------------------------------------APACHE 服务启动相关----------------------------------------

#### 启动服务的方法

`service httpd start`  
这是 redhat 的服务启动命令，并不是 Linux 自带的服务启动命令，不建议使用

`/etc/rc./init.d/httpd start`  
才是 Linux 自带的服务启动命令

RPM 安装包不建议指定安装位置，否则他的服务启动配置文件位置 就不会在/etc/下 ，启动命令 都会在/user/bin 或者 /user/sbin 下，这样 不管是 redhat 的 service 命令，还是 Linux 本身的 start 命令都不能正常启动服务源码包安装

源码包一定要安装在制定位置，一般都是在/usr/local/软件名源码包是没有卸载命令的，需要卸载的时候，直接删除安装目录就可以安装源码包使用的./configure 命令作用：定义需要的功能选项检测系统环境是否符合安装要求定义好的功能选项和检测环境的信息都写入 Makefile 文件，用于后续编辑

#### 源码包安装

* 源码包一定要安装在制定位置，一般都是在/usr/local/软件名
* 源码包是没有卸载命令的，需要卸载的时候，直接删除安装目录就可以
* 安装源码包使用的./configure 命令作用：
* 定义需要的功能选项
* 检测系统环境是否符合安装要求
* 定义好的功能选项和检测环境的信息都写入 Makefile 文件，用于后续编辑
